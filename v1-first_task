// Include necessary libraries
#include <Arduino.h>

// Define compile-time switch for DEBUG timing
#define DEBUG_TIMING

// Timing parameters
#ifdef DEBUG_TIMING
    #define TON1_DEBUG    100000  // DEBUG on-time in milliseconds (factor of 1000)
    #define TOFF_DEBUG    100000  // DEBUG off-time in milliseconds (factor of 1000)
    #define NUM_PULSES_DEBUG  10  // DEBUG number of pulses
    #define IDLE_TIME_DEBUG   200000 // DEBUG idle time between DATA and SYNC pulses
    #define TSYNC_ON_DEBUG    500000 // DEBUG SYNC on-time
#else
    #define TON1_PROD    100    // PRODUCTION on-time in milliseconds
    #define TOFF_PROD    100    // PRODUCTION off-time in milliseconds
    #define NUM_PULSES_PROD  5   // PRODUCTION number of pulses
    #define IDLE_TIME_PROD   200 // PRODUCTION idle time between DATA and SYNC pulses
    #define TSYNC_ON_PROD    50  // PRODUCTION SYNC on-time
#endif

// Define pin numbers for push buttons and outputs
const int PB1_PIN = 2; // Pin for Push Button 1
const int PB2_PIN = 3; // Pin for Push Button 2
const int DATA_PIN = 9; // Pin for DATA output
const int SYNC_PIN = 8; // Pin for SYNC output

// Operational state
enum SystemState {
    STATE_IDLE,
    STATE_OUTPUT_ENABLED,
    STATE_ALTERNATIVE_SELECTED
};

// Variable to store the current state
SystemState currentState = STATE_IDLE;

// Variable to store the User's Surname
String userSurname = "ab";

// Function prototypes
void handlePushButton1();
void handlePushButton2();
void generateDataWaveform();
void generateAlternativeDataWaveform();
void generateSyncPulse();
void calculateTimingParameters();

// Setup function
void setup() {
    // Set pin modes
    pinMode(PB1_PIN, INPUT_PULLUP);
    pinMode(PB2_PIN, INPUT_PULLUP);
    pinMode(DATA_PIN, OUTPUT);
    pinMode(SYNC_PIN, OUTPUT);

    Serial.begin(9600);
}

// Loop function
void loop() {
    // Check and handle push button inputs
    delayMicroseconds(100);
    handlePushButton1();
    handlePushButton2();
    Serial.println(currentState);
    // Generate appropriate waveforms based on the current state
    switch (currentState) {
        case STATE_OUTPUT_ENABLED:
            generateDataWaveform();
            break;
        case STATE_ALTERNATIVE_SELECTED:
            generateAlternativeDataWaveform();
            break;
        default:
            // Handle other states or do nothing in STATE_IDLE
            // Generate SYNC pulse
            generateSyncPulse();
            break;
    }
    calculateTimingParameters(userSurname);

    delay(5000);  // Delay for better readability in the serial monitor

}

// Function to handle the first push button
void handlePushButton1() {
  static unsigned long lastDebounceTimeUp = 0;
  static unsigned long debounceDelay = 500;

  // Check for a valid button state change (debouncing)
  if (digitalRead(PB1_PIN) == HIGH && currentState == STATE_IDLE) {
    lastDebounceTimeUp = millis();
    Serial.println("stage1");
    
  }

  // Check if the button state has remained stable for the debounce delay
  if ((millis() - lastDebounceTimeUp) > debounceDelay) {
    Serial.println("stage2");
    if (digitalRead(PB1_PIN) == LOW) {
      // Implementation to handle momentary press and change state
      currentState = STATE_OUTPUT_ENABLED;
      // For demonstration purposes, just print a message
      Serial.println("PushButton1 pressed");
    }
  }
}

// Function to handle the second push button
void handlePushButton2() {
  static unsigned long lastDebounceTimeUp = 0;
  static unsigned long debounceDelay = 500;

  // Check for a valid button state change (debouncing)
  if (digitalRead(PB2_PIN) == HIGH && currentState == STATE_IDLE) {
    lastDebounceTimeUp = millis();
    Serial.println("stage1"); 
    
  }
  
  // Check if the button state has remained stable for the debounce delay
  if ((millis() - lastDebounceTimeUp) > debounceDelay) {
    Serial.println("stage2");
    if (digitalRead(PB2_PIN) == LOW) {
      // Implementation to handle momentary press and change state
      currentState = STATE_ALTERNATIVE_SELECTED;
      // For demonstration purposes, just print a message
      Serial.println("PushButton2 pressed");

    }
  }
}

// Function to generate the normal DATA waveform
void generateDataWaveform() {
  int i = 0; 
  while(i < NUM_PULSES_DEBUG) {
    i+=1;
    digitalWrite(DATA_PIN, HIGH);  // Set DATA_PIN high for the pulse on-time
    delayMicroseconds(TON1_DEBUG);
        
    digitalWrite(DATA_PIN, LOW);   // Set DATA_PIN low for the pulse off-time
    delayMicroseconds(TOFF_DEBUG);
    Serial.println("generateDataWaveform");
  }
  currentState = STATE_IDLE;
  // Add idle time between the end of the final pulse off-time and the start of the next SYNC pulse
  delayMicroseconds(IDLE_TIME_DEBUG);
}

// Function to generate the alternative DATA waveform
void generateAlternativeDataWaveform() {
  int i = 0; 
  while(i < NUM_PULSES_DEBUG) {
    i+=1;
    // Custom pattern for the alternative waveform (modify as needed)
    digitalWrite(DATA_PIN, HIGH);
    delayMicroseconds(TON1_DEBUG);

    digitalWrite(DATA_PIN, LOW);
    delayMicroseconds(TOFF_DEBUG * 2); // Longer off-time for the alternative waveform
    Serial.println("generateAlternativeDataWaveform");
  }
    currentState = STATE_IDLE;
    // Add idle time between the end of the final pulse off-time and the start of the next SYNC pulse
    delayMicroseconds(IDLE_TIME_DEBUG);
}

// Function to generate the SYNC pulse
void generateSyncPulse() {
#ifdef DEBUG_TIMING
    const unsigned long TSYNC_ON = TSYNC_ON_DEBUG;
#else
    const unsigned long TSYNC_ON = TSYNC_ON_PROD;
#endif
    // Set SYNC_PIN high for the SYNC on-time
    digitalWrite(SYNC_PIN, HIGH);
    delayMicroseconds(TSYNC_ON_DEBUG);

    // Set SYNC_PIN low to complete the SYNC pulse
    digitalWrite(SYNC_PIN, LOW);
}

// Part 2
// Function to calculate the Output Timing Parameters
void calculateTimingParameters(const String& surname) {
    // Ensure the surname has at least one character
    if (surname.length() == 0) {
        Serial.println("Error: Surname is empty.");
        return;
    }

    // Extend the surname if it has less than four letters
    String extendedSurname = surname;
    while (extendedSurname.length() < 4) {
        extendedSurname += surname.charAt(surname.length() - 1);
    }

    // Extract the first four letters
    String firstFourLetters = extendedSurname.substring(0, 4);

    // Map each letter to its corresponding numeric value
    int mapping[4];
    for (int i = 0; i < 4; ++i) {
        char currentLetter = firstFourLetters[i];
        int numericValue = 0;

        // Map letters a-z to numeric values
        if (currentLetter >= 'a' && currentLetter <= 'z') {
            numericValue = currentLetter - 'a' + 1;
        }
        // Map letters A-Z to numeric values
        else if (currentLetter >= 'A' && currentLetter <= 'Z') {
            numericValue = currentLetter - 'A' + 1;
        }

        mapping[i] = numericValue;
    }

    // Calculate Output Timing Parameters
    unsigned long parameter1 = mapping[0] * 100;      // First Letter Numerical Mapping x 100us
    unsigned long parameter2 = mapping[1] * 100;      // Second Letter Numerical Mapping x 100us
    unsigned long parameter3 = (mapping[2] + 4) * 100; // Third Letter Numerical Mapping + 4
    unsigned long parameter4 = mapping[3] * 500;      // Fourth Letter Numerical Mapping x 500us

    // Print the calculated parameters
    Serial.print("Parameter 1: ");
    Serial.print(parameter1);
    Serial.println(" us");

    Serial.print("Parameter 2: ");
    Serial.print(parameter2);
    Serial.println(" us");

    Serial.print("Parameter 3: ");
    Serial.print(parameter3);
    Serial.println(" us");

    Serial.print("Parameter 4: ");
    Serial.print(parameter4);
    Serial.println(" us");
}
