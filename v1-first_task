#include <Arduino.h>

// Define compile-time switch for DEBUG timing
#define DEBUG_TIMING

// Timing parameters
#ifdef DEBUG_TIMING
    #define TON1_DEBUG    100000  // DEBUG on-time in milliseconds (factor of 1000)
    #define TOFF_DEBUG    100000  // DEBUG off-time in milliseconds (factor of 1000)
    #define NUM_PULSES_DEBUG  10  // DEBUG number of pulses
    #define IDLE_TIME_DEBUG   200000 // DEBUG idle time between DATA and SYNC pulses
    #define TSYNC_ON_DEBUG    5000  // DEBUG SYNC on-time
#else
    #define TON1_PROD    100    // PRODUCTION on-time in milliseconds
    #define TOFF_PROD    100    // PRODUCTION off-time in milliseconds
    #define NUM_PULSES_PROD  5   // PRODUCTION number of pulses
    #define IDLE_TIME_PROD   200 // PRODUCTION idle time between DATA and SYNC pulses
    #define TSYNC_ON_PROD    50  // PRODUCTION SYNC on-time
#endif

// Define pin numbers for push buttons and outputs
const int PB1_PIN = 2; // Pin for Push Button 1
const int PB2_PIN = 3; // Pin for Push Button 2
const int DATA_PIN = 9; // Pin for DATA output
const int SYNC_PIN = 8; // Pin for SYNC output

// Operational state
enum SystemState {
    STATE_IDLE,
    STATE_OUTPUT_ENABLED,
    STATE_ALTERNATIVE_SELECTED
};

// Variable to store the current state
SystemState currentState = STATE_IDLE;

// Function prototypes
void handlePushButton1();
void handlePushButton2();
void generateDataWaveform();
void generateAlternativeDataWaveform();
void generateSyncPulse();

// Setup function
void setup() {
    // Set pin modes
    pinMode(PB1_PIN, INPUT_PULLUP);
    pinMode(PB2_PIN, INPUT_PULLUP);
    pinMode(DATA_PIN, OUTPUT);
    pinMode(SYNC_PIN, OUTPUT);

    Serial.begin(9600);
}

// Loop function
void loop() {
    // Check and handle push button inputs
    delayMicroseconds(100);
    handlePushButton1();
    handlePushButton2();
    Serial.println(currentState);
    // Generate appropriate waveforms based on the current state
    switch (currentState) {
        case STATE_OUTPUT_ENABLED:
            generateDataWaveform();
            break;
        case STATE_ALTERNATIVE_SELECTED:
            generateAlternativeDataWaveform();
            break;
        default:
            // Handle other states or do nothing in STATE_IDLE
            break;
    }

}

// Function to handle the first push button
void handlePushButton1() {
    currentState = STATE_ALTERNATIVE_SELECTED;
    if (digitalRead(PB1_PIN) == LOW) {
        // Implementation to handle momentary press and change state
        currentState = STATE_ALTERNATIVE_SELECTED;

        // For demonstration purposes, just print a message
        Serial.println("PushButton1 pressed");
    }
}

// Function to handle the second push button
void handlePushButton2() {
    if (digitalRead(PB2_PIN) == LOW) {
        // Implementation to handle momentary press and change state
        currentState = STATE_OUTPUT_ENABLED;

        // For demonstration purposes, just print a message
        Serial.println("PushButton2 pressed");
    }

    else {
      currentState = STATE_IDLE;
    }
}

// Function to generate the normal DATA waveform
void generateDataWaveform() {
  for (int i = 0; i < NUM_PULSES_DEBUG; ++i) {
    digitalWrite(DATA_PIN, HIGH);  // Set DATA_PIN high for the pulse on-time
    delayMicroseconds(TON1_DEBUG);
        
    digitalWrite(DATA_PIN, LOW);   // Set DATA_PIN low for the pulse off-time
    delayMicroseconds(TOFF_DEBUG);
    Serial.println("generateDataWaveform");
  }

  // Add idle time between the end of the final pulse off-time and the start of the next SYNC pulse
  delayMicroseconds(IDLE_TIME_DEBUG);
}

// Function to generate the alternative DATA waveform
void generateAlternativeDataWaveform() {
    // Implementation for an alternative waveform
    for (int i = 0; i < NUM_PULSES_DEBUG; ++i) {
        // Custom pattern for the alternative waveform (modify as needed)
        digitalWrite(DATA_PIN, HIGH);
        delayMicroseconds(TON1_DEBUG);

        digitalWrite(DATA_PIN, LOW);
        delayMicroseconds(TOFF_DEBUG * 2); // Longer off-time for the alternative waveform
        Serial.println("generateAlternativeDataWaveform");
    }

    // Add idle time between the end of the final pulse off-time and the start of the next SYNC pulse
    delayMicroseconds(IDLE_TIME_DEBUG);
}
